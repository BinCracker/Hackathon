##CBC-MAC 消息伪造
让我们来聊一聊 CBC-MAC  

CBC-MAC 可以这样描述：
1. 构造一个明文 P
2. 使用 CBC 模式和密钥 k 来加密 P，生成密文 C
3. 丢弃到除了最后字符块 C[n] 之外的其他 C
4. C[n] 就是一个 MAC

假设这里有一个在线银行应用，它通过与 API 服务器通信来执行用户的请求，每一个请求看上去像这样：  
`message||IV||MAC`  

message 看上去像这样：  
`from=#{from_id}&to=#{to_id}&amount=#{amount}`  

现在，请为该服务编写一个 API 服务器和 web 前端(NOTE: 不需要真的写一个实际的服务器和web应用，完全可以只编写必要的工作)。用户端和服务器端应当共享一个密钥 k 来签名和验证 message。  

API 服务器应当具备接收 message、验证签名和当 MAC 有效时进行交易的功能。这些功能是公开的，攻击者可以自由得提交 message 只要他能伪造出正确的密钥。  

web客户端应当允许攻击者使用他控制的帐户生成有效的 message(如果你十分注重细节，你可以进行参数过滤)。假设攻击者具有捕获和监听从客户端到 API 服务器的 message 的能力。  

还有一个我们没有讨论的事情，就是 IV，假设客户端生成了一个 pre-message IV 然后通过 MAC 发送它，这个 CBC 怎么工作呢，对吧？  
这是错误的。  

通过 CBC-MAC 签名的 message，一个被攻击者控制的 IV 是完全有可能的。为什么？因为 message 的第一个快可以被完全得控制。  

使用这些事实来生成一个 message ，来从受害者账户到你的账户转移 1M 的 spacebucks(译者注：space bucks是一个古老的模拟太空贸易的游戏，用在这里应该是一个梗)。  

我的心在等待永远在等待~当你做成功了记得告诉我
在等待~  
在等待~~  
在等待~~~  
成功了？好的，我知道你可以的！  

现在让我们来调节一下这个协议。  
正如我们知道的，你被确信使用一个固定的 IV来使用 CBC-MAC，让我们接着做，我们将会设置我们的 IV，简单得从0开始，这意味着 IV 可以从协议的请求中去掉了：  
`message||MAC`  
非常简单，不过我们还是要调节一下 message，为了效率，银行想要在一次请求中处理多条交易，于是 message 现在看起来像这样:  
`from=#{from_id}&tx_list=#{transactions}`  
其中交易列表(tx_list)的格式像这样：  
`to:amount(;to:amount)*`  

这里有一个缺陷： MAC 十分容易受到扩展长度攻击。怎么做呢？  
输出的 CBC-MAC 是一个新消息的有效 IV。
“但是我们不会以任何方式控制 IV”  
只要对 CBC 足够了解，我们可以伪造它。  
`你的任务：从你的目标用户那里捕获有效的 message，使用扩展长度攻击添加一条交易支付给攻击者账户 1M spacebucks。`  

####提示：如果你可以完全控制你的 message 的第一块，这是很容易的，对吧？也许你可以假冒它。
