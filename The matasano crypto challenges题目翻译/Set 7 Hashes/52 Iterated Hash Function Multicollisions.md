##迭代哈希函数冲突
现在我们的话题是哈希函数。  

你想让你的哈希函数所具有的主要功能是碰撞抵抗的能力，这使得它很难生成碰撞，它应当真的很难生成给定哈希值的碰撞(也叫做原像)。  

迭代哈希函数有一个问题：会产生大量的次线性缩放碰撞(collisions scales sublinearly)。  

什么是一个迭代哈希函数？为了说明，我们来看 Merkle-Damgard 结构，它看上去像是：  
```
function MD(M, H, C):
  for M[i] in pad(M):
    H := C(M[i], H)
  return H
```
一个消息 M，初始状态 H，以及压缩函数 C。  

这应该看上去很相似，因为 SHA-1 和 MD4 都是这种类别的。最酷的是你可以用这个方程来建立一个临时的哈希函数，通过你周围的一些基本加密单元。(例如 C = AES-128)  

让我们回到任务：次线性缩放碰撞的成本，这意味着什么？如果它可以找到一个碰撞，它就能找到很多碰撞。  

怎么做？给定一个状态 H，找到两个碰撞块，现在使用这个碰撞的结果的哈希函数作为你的新的状态 H，再次重复。找到每一次迭代，你确切得可以通过替代两个块来加倍你的碰撞。  

这意味着如果找到了两个碰撞消息，进行 2^(b/2) 的工作(b是哈希函数的比特长度)，之后，找到 2^n 的碰撞只需要 n*2^(b/2) 的工作。  

让我们测试一下，首先，建立你自己的 MD 哈希函数，我们将会生成很多碰撞，不要把这当自己家了，事实上，跳出你的方式，让它变得糟糕，这是一种方法：  
1. 做一个快速的分组密码，来作为 C  
2. 让 H 很小，如果它只有16位，我不会看不起你的。选择一些起始 H。  
3. H 作为输入密钥以及从 C 输出块，这意味着需要在输入时填充，在输出时丢弃比特。  

现在编写函数 f(n) 这将生成 2^n 的这个哈希函数的碰撞。  

这有什么问题？一个原因是，人们尝试通过串联哈希函数来加强它，这是我的想法：  
1. 设哈希函数 f 和 g  
2. 构造一个 h，h(x)=f(x)||g(x)  

一个主意是，如果碰撞在 f 中代价是 2^(b1/2)，而碰撞在 g 中代价是2^(b2/2)，那么碰撞在 h 中就是 2^((b1+b2)/2)。  

但是现在我们知道这并不是真的。  

这是一些想法：  
1. 选择一个“便宜的”哈希函数，例如 f  
2. 对 f 生成 2^(b2/2) 的碰撞消息  
3. 有很大的可能性你的消息池在 g 中有一个碰撞  
4. 找到它  

如果没找到，继续生成"廉价的"碰撞，直到你找到它。  

通过建立一个更昂贵的(但不是非常昂贵)哈希函数对你所使用的进行配对来证明这一点。找到一对消息，在两个函数中都碰撞，测量碰撞函数调用的总数。
